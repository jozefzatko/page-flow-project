{
  "controllers": [
    {
      "methodName": "list",
      "requestMapping": "/develop/apps",
      "httpMethod": "GET",
      "className": "AppController",
      "classFilePath": "",
      "alwaysAccessible": true,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public List<AppSummary> list(Account account)",
      "methodBody": "{\r\n    return connectedAppRepository.findAppSummaries(account.getId());\r\n}"
    },
    {
      "methodName": "newForm",
      "requestMapping": "/develop/apps/new",
      "httpMethod": "GET",
      "className": "AppController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public AppForm newForm()",
      "methodBody": "{\r\n    return connectedAppRepository.getNewAppForm();\r\n}"
    },
    {
      "methodName": "create",
      "requestMapping": "/develop/apps",
      "httpMethod": "POST",
      "className": "AppController",
      "classFilePath": "",
      "alwaysAccessible": true,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String create(@Valid AppForm form, BindingResult bindingResult, Account account)",
      "methodBody": "{\r\n    if (bindingResult.hasErrors()) {\r\n        return \"develop/apps/new\";\r\n    }\r\n    return \"redirect:/develop/apps/\" + connectedAppRepository.createApp(account.getId(), form);\r\n}"
    },
    {
      "methodName": "view",
      "requestMapping": "/develop/apps/{slug}",
      "httpMethod": "GET",
      "className": "AppController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String view(@PathVariable String slug, Account account, Model model)",
      "methodBody": "{\r\n    model.addAttribute(connectedAppRepository.findAppBySlug(account.getId(), slug));\r\n    model.addAttribute(\"slug\", slug);\r\n    return \"develop/apps/view\";\r\n}"
    },
    {
      "methodName": "delete",
      "requestMapping": "/develop/apps/{slug}",
      "httpMethod": "DELETE",
      "className": "AppController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String delete(@PathVariable String slug, Account account)",
      "methodBody": "{\r\n    connectedAppRepository.deleteApp(account.getId(), slug);\r\n    return \"redirect:/develop/apps\";\r\n}"
    },
    {
      "methodName": "editForm",
      "requestMapping": "/develop/apps/edit/{slug}",
      "httpMethod": "GET",
      "className": "AppController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String editForm(@PathVariable String slug, Account account, Model model)",
      "methodBody": "{\r\n    model.addAttribute(connectedAppRepository.getAppForm(account.getId(), slug));\r\n    model.addAttribute(\"slug\", slug);\r\n    return \"develop/apps/edit\";\r\n}"
    },
    {
      "methodName": "update",
      "requestMapping": "/develop/apps/{slug}",
      "httpMethod": "PUT",
      "className": "AppController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String update(@PathVariable String slug, @Valid AppForm form, BindingResult bindingResult, Account account, Model model)",
      "methodBody": "{\r\n    if (bindingResult.hasErrors()) {\r\n        model.addAttribute(\"slug\", slug);\r\n        return \"develop/apps/edit\";\r\n    }\r\n    return \"redirect:/develop/apps/\" + connectedAppRepository.updateApp(account.getId(), slug, form);\r\n}"
    },
    {
      "methodName": "confirmAccessForm",
      "requestMapping": "/oauth/confirm_access",
      "httpMethod": "GET",
      "className": "ConfirmAccessController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "protected String confirmAccessForm(@RequestParam(\"client_id\") String apiKey, Model model) throws InvalidRequestTokenException, InvalidApiKeyException",
      "methodBody": "{\r\n    model.addAttribute(\"clientApp\", appRepository.findAppByApiKey(apiKey));\r\n    return \"oauth/confirmAccess\";\r\n}"
    },
    {
      "methodName": "upcomingEvents",
      "requestMapping": "/events",
      "httpMethod": "GET",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": true,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public List<Event> upcomingEvents(@RequestParam(value = \"after\", required = false) @DateTimeFormat(iso = ISO.DATE_TIME) Long afterMillis)",
      "methodBody": "{\r\n    return eventRepository.findUpcomingEvents(afterMillis);\r\n}"
    },
    {
      "methodName": "favorites",
      "requestMapping": "/events/{eventId}/favorites",
      "httpMethod": "GET",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public List<EventSession> favorites(@PathVariable Long eventId, Account account)",
      "methodBody": "{\r\n    return eventRepository.findEventFavorites(eventId, account.getId());\r\n}"
    },
    {
      "methodName": "tweets",
      "requestMapping": "/events/{eventId}/tweets",
      "httpMethod": "GET",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public SearchResults tweets(@PathVariable Long eventId, @RequestParam(defaultValue = \"1\") Integer page, @RequestParam(defaultValue = \"10\") Integer pageSize)",
      "methodBody": "{\r\n    String searchString = eventRepository.findEventSearchString(eventId);\r\n    return searchString != null && searchString.length() > 0 ? twitter.searchOperations().search(searchString, page, pageSize) : null;\r\n}"
    },
    {
      "methodName": "postTweet",
      "requestMapping": "/events/{eventId}/tweets",
      "httpMethod": "POST",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public ResponseEntity<String> postTweet(@PathVariable Long eventId, @RequestParam String status, Location currentLocation)",
      "methodBody": "{\r\n    twitter.timelineOperations().updateStatus(status);\r\n    return new ResponseEntity<String>(HttpStatus.OK);\r\n}"
    },
    {
      "methodName": "postRetweet",
      "requestMapping": "/events/{eventId}/retweet",
      "httpMethod": "POST",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public ResponseEntity<String> postRetweet(@PathVariable Long eventId, @RequestParam Long tweetId)",
      "methodBody": "{\r\n    twitter.timelineOperations().retweet(tweetId);\r\n    return new ResponseEntity<String>(HttpStatus.OK);\r\n}"
    },
    {
      "methodName": "favoriteSessions",
      "requestMapping": "/events/{eventId}/sessions/favorites",
      "httpMethod": "GET",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public List<EventSession> favoriteSessions(@PathVariable Long eventId, Account account)",
      "methodBody": "{\r\n    return eventRepository.findAttendeeFavorites(eventId, account.getId());\r\n}"
    },
    {
      "methodName": "sessionsOnDay",
      "requestMapping": "/events/{eventId}/sessions/{day}",
      "httpMethod": "GET",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public List<EventSession> sessionsOnDay(@PathVariable Long eventId, @PathVariable @DateTimeFormat(iso = ISO.DATE) LocalDate day, Account account)",
      "methodBody": "{\r\n    return eventRepository.findSessionsOnDay(eventId, day, account.getId());\r\n}"
    },
    {
      "methodName": "toggleFavorite",
      "requestMapping": "/events/{eventId}/sessions/{sessionId}/favorite",
      "httpMethod": "PUT",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public Boolean toggleFavorite(@PathVariable Long eventId, @PathVariable Integer sessionId, Account account)",
      "methodBody": "{\r\n    return eventRepository.toggleFavorite(eventId, sessionId, account.getId());\r\n}"
    },
    {
      "methodName": "updateRating",
      "requestMapping": "/events/{eventId}/sessions/{sessionId}/rating",
      "httpMethod": "POST",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public Float updateRating(@PathVariable Long eventId, @PathVariable Integer sessionId, Account account, @RequestParam Short value, @RequestParam String comment) throws RatingPeriodClosedException",
      "methodBody": "{\r\n    return eventRepository.rate(eventId, sessionId, account.getId(), new Rating(value, comment));\r\n}"
    },
    {
      "methodName": "sessionTweets",
      "requestMapping": "/events/{eventId}/sessions/{sessionId}/tweets",
      "httpMethod": "GET",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public SearchResults sessionTweets(@PathVariable Long eventId, @PathVariable Integer sessionId, @RequestParam(defaultValue = \"1\") Integer page, @RequestParam(defaultValue = \"10\") Integer pageSize)",
      "methodBody": "{\r\n    String searchString = eventRepository.findSessionSearchString(eventId, sessionId);\r\n    return searchString != null && searchString.length() > 0 ? twitter.searchOperations().search(searchString, page, pageSize) : null;\r\n}"
    },
    {
      "methodName": "postSessionTweet",
      "requestMapping": "/events/{eventId}/sessions/{sessionId}/tweets",
      "httpMethod": "POST",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public ResponseEntity<String> postSessionTweet(@PathVariable Long eventId, @PathVariable Integer sessionId, @RequestParam String status, Location currentLocation)",
      "methodBody": "{\r\n    twitter.timelineOperations().updateStatus(status);\r\n    return new ResponseEntity<String>(HttpStatus.OK);\r\n}"
    },
    {
      "methodName": "postSessionRetweet",
      "requestMapping": "/events/{eventId}/sessions/{sessionId}/retweet",
      "httpMethod": "POST",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public ResponseEntity<String> postSessionRetweet(@PathVariable Long eventId, @PathVariable Integer sessionId, @RequestParam Long tweetId)",
      "methodBody": "{\r\n    twitter.timelineOperations().retweet(tweetId);\r\n    return new ResponseEntity<String>(HttpStatus.OK);\r\n}"
    },
    {
      "methodName": "upcomingEventsView",
      "requestMapping": "/events",
      "httpMethod": "GET",
      "className": "EventsController",
      "classFilePath": "",
      "alwaysAccessible": true,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String upcomingEventsView(Model model, DateTimeZone timeZone)",
      "methodBody": "{\r\n    model.addAttribute(eventRepository.findUpcomingEvents(new DateTime(timeZone).getMillis()));\r\n    return \"events/list\";\r\n}"
    },
    {
      "methodName": "showEventLoadForm",
      "requestMapping": "/admin/load",
      "httpMethod": "GET",
      "className": "EventLoadController",
      "classFilePath": "/admin",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String showEventLoadForm()",
      "methodBody": "{\r\n    return \"admin/load\";\r\n}"
    },
    {
      "methodName": "updateEvent",
      "requestMapping": "/admin/load",
      "httpMethod": "POST",
      "className": "EventLoadController",
      "classFilePath": "/admin",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String updateEvent(@RequestParam(\"showId\") int showId)",
      "methodBody": "{\r\n    loader.loadEventData(showId);\r\n    return \"redirect:/admin/load\";\r\n}"
    },
    {
      "methodName": "groupView",
      "requestMapping": "/groups/{groupKey}",
      "httpMethod": "",
      "className": "GroupsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String groupView(@PathVariable String groupKey, Model model)",
      "methodBody": "{\r\n    Group group = groupRepository.findGroupBySlug(groupKey);\r\n    model.addAttribute(group);\r\n    model.addAttribute(\"metadata\", buildOpenGraphMetadata(group));\r\n    model.addAttribute(\"facebookAppId\", facebookAppId);\r\n    return \"groups/view\";\r\n}"
    },
    {
      "methodName": "eventView",
      "requestMapping": "/groups/{group}/events/{year}/{month}/{slug}",
      "httpMethod": "GET",
      "className": "GroupsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String eventView(@PathVariable String group, @PathVariable Integer year, @PathVariable Integer month, @PathVariable String slug, Model model)",
      "methodBody": "{\r\n    Event event = eventRepository.findEventBySlug(group, year, month, slug);\r\n    model.addAttribute(event);\r\n    return \"groups/event\";\r\n}"
    },
    {
      "methodName": "home",
      "requestMapping": "/",
      "httpMethod": "GET",
      "className": "HomeController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String home(Principal user)",
      "methodBody": "{\r\n    return user != null ? \"homeSignedIn\" : \"homeNotSignedIn\";\r\n}"
    },
    {
      "methodName": "friendFinder",
      "requestMapping": "/invite/facebook",
      "httpMethod": "GET",
      "className": "FacebookInviteController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public void friendFinder(Model model, Account account)",
      "methodBody": "{\r\n    if (facebook.isAuthorized()) {\r\n        List<ProfileReference> profileReferences = accountRepository.findProfileReferencesByIds(friendAccountIds(account.getId(), facebook));\r\n        model.addAttribute(\"friends\", profileReferences);\r\n    } else {\r\n        model.addAttribute(\"friends\", Collections.emptySet());\r\n    }\r\n    model.addAttribute(\"facebookAppId\", facebookAppId);\r\n}"
    },
    {
      "methodName": "invitationsSent",
      "requestMapping": "/invite/facebook/request-form",
      "httpMethod": "POST",
      "className": "FacebookInviteController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String invitationsSent(@RequestParam(\"ids[]\") String[] inviteIds, RedirectAttributes redirectAttrs)",
      "methodBody": "{\r\n    redirectAttrs.addFlashAttribute(Message.success(\"Your invitations have been sent\"));\r\n    return \"redirect:/invite\";\r\n}"
    },
    {
      "methodName": "invitationsCancelled",
      "requestMapping": "/invite/facebook/request-form",
      "httpMethod": "GET",
      "className": "FacebookInviteController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String invitationsCancelled()",
      "methodBody": "{\r\n    return \"redirect:/invite\";\r\n}"
    },
    {
      "methodName": "invitePage",
      "requestMapping": "/invite",
      "httpMethod": "GET",
      "className": "InviteController",
      "classFilePath": "",
      "alwaysAccessible": true,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public void invitePage(@FacebookCookieValue(value = \"uid\", required = false) String facebookUserId, Model model)",
      "methodBody": "{\r\n    model.addAttribute(\"facebookUserId\", facebookUserId);\r\n    model.addAttribute(\"facebookAppId\", facebookAppId);\r\n}"
    },
    {
      "methodName": "acceptInvitePage",
      "requestMapping": "/invite/accept",
      "httpMethod": "GET",
      "className": "InviteController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String acceptInvitePage(@RequestParam String token, Model model, HttpServletResponse response) throws IOException",
      "methodBody": "{\r\n    try {\r\n        Invite invite = inviteRepository.findInvite(token);\r\n        model.addAttribute(invite.getInvitee());\r\n        model.addAttribute(\"sentBy\", invite.getSentBy());\r\n        model.addAttribute(invite.createSignupForm());\r\n        model.addAttribute(\"token\", token);\r\n        return \"invite/accept\";\r\n    } catch (InviteException e) {\r\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n        return null;\r\n    }\r\n}"
    },
    {
      "methodName": "acceptInvite",
      "requestMapping": "/invite/accept",
      "httpMethod": "POST",
      "className": "InviteController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String acceptInvite(@RequestParam final String token, @Valid SignupForm form, BindingResult formBinding, Model model)",
      "methodBody": "{\r\n    if (formBinding.hasErrors()) {\r\n        return form(token, model);\r\n    }\r\n    boolean result = signupHelper.signup(form, formBinding, new SignupCallback() {\r\n\r\n        public void postSignup(Account account) {\r\n            inviteRepository.markInviteAccepted(token, account);\r\n        }\r\n    });\r\n    return result ? \"redirect:/\" : form(token, model);\r\n}"
    },
    {
      "methodName": "invitePage",
      "requestMapping": "/invite/mail",
      "httpMethod": "GET",
      "className": "MailInviteController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public MailInviteForm invitePage(Account account)",
      "methodBody": "{\r\n    MailInviteForm form = new MailInviteForm();\r\n    form.setInvitationText(renderStandardInvitationText(account));\r\n    return form;\r\n}"
    },
    {
      "methodName": "sendInvites",
      "requestMapping": "/invite/mail",
      "httpMethod": "POST",
      "className": "MailInviteController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String sendInvites(@Valid MailInviteForm form, BindingResult result, Account account, RedirectAttributes redirectAttrs)",
      "methodBody": "{\r\n    if (result.hasErrors()) {\r\n        return null;\r\n    }\r\n    inviteService.sendInvite(account, form.getInvitees(), form.getInvitationText());\r\n    redirectAttrs.addFlashAttribute(Message.success(\"Your invitations have been sent\"));\r\n    return \"redirect:/invite/mail\";\r\n}"
    },
    {
      "methodName": "friendFinder",
      "requestMapping": "/invite/twitter",
      "httpMethod": "GET",
      "className": "TwitterInviteController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public void friendFinder(Model model)",
      "methodBody": "{\r\n    if (twitter.isAuthorized()) {\r\n        model.addAttribute(\"username\", twitter.userOperations().getScreenName());\r\n    }\r\n}"
    },
    {
      "methodName": "findFriends",
      "requestMapping": "/invite/twitter",
      "httpMethod": "POST",
      "className": "TwitterInviteController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String findFriends(@RequestParam String username, Model model)",
      "methodBody": "{\r\n    // TODO: consider making a Get request instead of a Post since there are no side effects\r\n    if (StringUtils.hasText(username)) {\r\n        List<ProfileReference> profileReferences = accountRepository.findProfileReferencesByIds(friendAccountIds(username));\r\n        model.addAttribute(\"friends\", profileReferences);\r\n    }\r\n    return \"invite/twitterFriends\";\r\n}"
    },
    {
      "methodName": "profile",
      "requestMapping": "/members/@self",
      "httpMethod": "GET",
      "className": "MembersController",
      "classFilePath": "/members",
      "alwaysAccessible": false,
      "pageController": false,
      "restController": true,
      "methodDeclaration": "public Profile profile(Account account)",
      "methodBody": "{\r\n    return profileRepository.findByAccountId(account.getId());\r\n}"
    },
    {
      "methodName": "profileView",
      "requestMapping": "/members/{profileKey}",
      "httpMethod": "GET",
      "className": "MembersController",
      "classFilePath": "/members",
      "alwaysAccessible": true,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String profileView(@PathVariable String profileKey, Model model)",
      "methodBody": "{\r\n    Profile profile = profileRepository.findById(profileKey);\r\n    model.addAttribute(profile);\r\n    model.addAttribute(\"connectedProfiles\", profileRepository.findConnectedProfiles(profile.getAccountId()));\r\n    model.addAttribute(\"metadata\", buildFacebookOpenGraphMetadata(profile));\r\n    model.addAttribute(\"facebookAppId\", facebookAppId);\r\n    return \"members/view\";\r\n}"
    },
    {
      "methodName": "resetPage",
      "requestMapping": "/reset",
      "httpMethod": "GET",
      "className": "ResetPasswordController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public void resetPage(Model model)",
      "methodBody": "{\r\n    model.addAttribute(\"username\", new FieldModel<String>());\r\n}"
    },
    {
      "methodName": "sendResetMail",
      "requestMapping": "/reset",
      "httpMethod": "POST",
      "className": "ResetPasswordController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String sendResetMail(@RequestParam String signin, Model model, RedirectAttributes redirectAttrs)",
      "methodBody": "{\r\n    try {\r\n        service.sendResetMail(signin);\r\n        redirectAttrs.addFlashAttribute(Message.info(\"An email has been sent to you.  Follow its instructions to reset your password.\"));\r\n        return \"redirect:/reset\";\r\n    } catch (SignInNotFoundException e) {\r\n        model.addAttribute(\"signin\", FieldModel.error(\"not on file\", signin));\r\n        return null;\r\n    }\r\n}"
    },
    {
      "methodName": "changePasswordForm",
      "requestMapping": "/reset",
      "httpMethod": "GET",
      "className": "ResetPasswordController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String changePasswordForm(@RequestParam String token, Model model)",
      "methodBody": "{\r\n    if (!service.isValidResetToken(token)) {\r\n        return \"reset/invalidToken\";\r\n    }\r\n    model.addAttribute(new ChangePasswordForm());\r\n    return \"reset/changePassword\";\r\n}"
    },
    {
      "methodName": "changePassword",
      "requestMapping": "/reset",
      "httpMethod": "POST",
      "className": "ResetPasswordController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String changePassword(@RequestParam String token, @Valid ChangePasswordForm form, BindingResult formBinding, Model model, RedirectAttributes redirectAttrs)",
      "methodBody": "{\r\n    if (formBinding.hasErrors()) {\r\n        model.addAttribute(\"token\", token);\r\n        return \"reset/changePassword\";\r\n    }\r\n    try {\r\n        service.changePassword(token, form.getPassword());\r\n        redirectAttrs.addFlashAttribute(\"Your password has been reset\");\r\n        return \"redirect:/reset\";\r\n    } catch (InvalidResetTokenException e) {\r\n        redirectAttrs.addFlashAttribute(Message.error(\"Your reset password session has expired.  Please try again.\"));\r\n        return \"redirect:/reset\";\r\n    }\r\n}"
    },
    {
      "methodName": "settingsPage",
      "requestMapping": "/settings",
      "httpMethod": "GET",
      "className": "SettingsController",
      "classFilePath": "",
      "alwaysAccessible": true,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public void settingsPage(Account account, Model model)",
      "methodBody": "{\r\n    // TODO: Fix this query\r\n    List<Map<String, Object>> apps = jdbcTemplate.queryForList(\"select a.name as name, c.token_id as accessToken from App a, oauth_access_token c where c.client_id = a.apiKey and c.user_name = ?\", account.getId() + \"\");\r\n    model.addAttribute(\"apps\", apps);\r\n}"
    },
    {
      "methodName": "disconnectApp",
      "requestMapping": "/settings/apps/{accessToken}",
      "httpMethod": "DELETE",
      "className": "SettingsController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String disconnectApp(@PathVariable String accessToken, Account account)",
      "methodBody": "{\r\n    tokenStore.removeAccessToken(new DefaultOAuth2AccessToken(accessToken));\r\n    return \"redirect:/settings\";\r\n}"
    },
    {
      "methodName": "signin",
      "requestMapping": "/signin",
      "httpMethod": "GET",
      "className": "SigninController",
      "classFilePath": "",
      "alwaysAccessible": true,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public void signin()",
      "methodBody": "{\r\n}"
    },
    {
      "methodName": "signupForm",
      "requestMapping": "/signup",
      "httpMethod": "GET",
      "className": "SignupController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public SignupForm signupForm(WebRequest request)",
      "methodBody": "{\r\n    Connection<?> connection = ProviderSignInUtils.getConnection(request);\r\n    if (connection != null) {\r\n        request.setAttribute(\"message\", new Message(MessageType.INFO, \"Your \" + StringUtils.capitalize(connection.getKey().getProviderId()) + \" account is not associated with a Greenhouse account. If you're new, please sign up.\"), WebRequest.SCOPE_REQUEST);\r\n        return SignupForm.fromProviderUser(connection.fetchUserProfile());\r\n    } else {\r\n        return new SignupForm();\r\n    }\r\n}"
    },
    {
      "methodName": "signup",
      "requestMapping": "/signup",
      "httpMethod": "POST",
      "className": "SignupController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public String signup(@Valid SignupForm form, BindingResult formBinding, final WebRequest request)",
      "methodBody": "{\r\n    if (formBinding.hasErrors()) {\r\n        return null;\r\n    }\r\n    boolean result = signupHelper.signup(form, formBinding, new SignupCallback() {\r\n\r\n        public void postSignup(Account account) {\r\n            ProviderSignInUtils.handlePostSignUp(account.getId().toString(), request);\r\n        }\r\n    });\r\n    return result ? \"redirect:/\" : null;\r\n}"
    },
    {
      "methodName": "signupFromApi",
      "requestMapping": "/signup",
      "httpMethod": "POST",
      "className": "SignupController",
      "classFilePath": "",
      "alwaysAccessible": false,
      "pageController": true,
      "restController": false,
      "methodDeclaration": "public ResponseEntity<Map<String, Object>> signupFromApi(@RequestBody SignupForm form)",
      "methodBody": "{\r\n    // Temporary manual validation until SPR-9826 is fixed.\r\n    BindingResult formBinding = validate(form);\r\n    if (formBinding.hasErrors()) {\r\n        HashMap<String, Object> errorResponse = new HashMap<String, Object>();\r\n        errorResponse.put(\"message\", \"Validation error\");\r\n        errorResponse.put(\"errors\", getErrorsMap(formBinding));\r\n        return new ResponseEntity<Map<String, Object>>(errorResponse, HttpStatus.BAD_REQUEST);\r\n    }\r\n    boolean result = signupHelper.signup(form, formBinding);\r\n    if (result) {\r\n        HashMap<String, Object> errorResponse = new HashMap<String, Object>();\r\n        errorResponse.put(\"message\", \"Account created\");\r\n        return new ResponseEntity<Map<String, Object>>(errorResponse, HttpStatus.CREATED);\r\n    } else {\r\n        HashMap<String, Object> errorResponse = new HashMap<String, Object>();\r\n        errorResponse.put(\"message\", \"Account creation error\");\r\n        errorResponse.put(\"errors\", getErrorsMap(formBinding));\r\n        return new ResponseEntity<Map<String, Object>>(errorResponse, HttpStatus.BAD_REQUEST);\r\n    }\r\n}"
    }
  ]
}